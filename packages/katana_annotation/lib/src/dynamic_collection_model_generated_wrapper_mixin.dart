part of katana_annotation;

/// Gives DynamicCollectionModel functionality to the objects generated by the Builder.
mixin DynamicCollectionModelGeneratedWrapperMixin<T> {
  /// Returns the DynamicCollectionModel entity.
  DynamicCollectionModel collection();

  /// Create a new document.
  ///
  /// [id] is the ID of the document. If it is blank, [uuid] is used.
  T create([String? id]);

  /// Remove elements in the collection that are `true` in [test].
  Future<void> delete(bool Function(T value) test);

  /// Add a new document to the current collection based on [uid].
  ///
  /// It is possible to specify data to be added to the document by giving [data].
  Future<void> append(String uid, {T? data});

  /// Provides the best data acquisition method to implement during screen build.
  ///
  /// Data loading does not occur in duplicate when a screen is built multiple times.
  ///
  /// Basically, it listens for data.
  /// If [listen] is set to `false`, load only.
  Future<void> fetch([bool listen = true]) {
    return collection().fetch(listen);
  }

  /// Data stored in the model is stored in a database external to the app that is tied to the model.
  ///
  /// The updated [Result] can be obtained at the stage where the loading is finished.
  Future<void> save() {
    return collection().save();
  }

  /// Reload data and updates the data in the model.
  ///
  /// It is basically the same as the [load] method,
  /// but combining it with [loadOnce] makes it easier to manage the data.
  Future<void> reload() {
    return collection().reload();
  }

  /// Load the data on the next page.
  ///
  /// If there is no data, [load()] is executed.
  Future<void> next() {
    return collection().next();
  }

  /// Returns True if the following reads are possible
  ///
  /// Returns False if no data has been read yet and no limit has been set.
  bool get canNext {
    return collection().canNext;
  }
}
