part of '/masamune.dart';

/// You can configure reorderable lists in a similar fashion to [ListBuilder].
///
/// Data is passed to [source] and each element is generated by [builder].
///
/// By defining [onReorder], a callback can be specified when the order is changed, and the actual data can be changed.
///
/// If [top] is set, the [top] elements are lined up before the [source] elements are lined up.
///
/// If [bottom] is set, the elements of [bottom] are lined up after the elements of [source] are lined up.
///
/// When [insert] is set, [insert] is inserted at the position of [insertPosition] in [source].
///
/// If [listenWhenListenable] is `true`, [ListenableListener] will be wrapped around each element if [source] inherits [Listenable].
/// Therefore, each element of [source] is monitored individually, and if any element is updated, only that element is updated in the drawing.
///
/// [ListBuilder]と同じような形で順番変更可能なリストを構成することができます。
///
/// [source]にデータを渡し、[builder]で各要素の生成を行います。
///
/// [onReorder]を定義することで順番が変更されたときのコールバックを指定することができ、実データの変更を行うことが可能です。
///
/// [top]を設定すると[source]の要素を並べる前に[top]の要素を並べます。
///
/// [bottom]を設定すると[source]の要素を並べた後に[bottom]の要素を並べます。
///
/// [insert]を設定すると[source]の[insertPosition]の位置に[insert]が挿入されます。
///
/// [listenWhenListenable]が`true`になっている場合、[source]に[Listenable]を継承している場合[ListenableListener]が各要素にラップされます。
/// そのため、[source]の各要素をそれぞれ監視し、いずれかの要素が更新された場合その要素のみ描画が更新されます。
class ReorderableListBuilder<T> extends StatefulWidget {
  /// You can configure reorderable lists in a similar fashion to [ListBuilder].
  ///
  /// Data is passed to [source] and each element is generated by [builder].
  ///
  /// By defining [onReorder], a callback can be specified when the order is changed, and the actual data can be changed.
  ///
  /// If [top] is set, the [top] elements are lined up before the [source] elements are lined up.
  ///
  /// If [bottom] is set, the elements of [bottom] are lined up after the elements of [source] are lined up.
  ///
  /// When [insert] is set, [insert] is inserted at the position of [insertPosition] in [source].
  ///
  /// If [listenWhenListenable] is `true`, [ListenableListener] will be wrapped around each element if [source] inherits [Listenable].
  /// Therefore, each element of [source] is monitored individually, and if any element is updated, only that element is updated in the drawing.
  ///
  /// [ListBuilder]と同じような形で順番変更可能なリストを構成することができます。
  ///
  /// [source]にデータを渡し、[builder]で各要素の生成を行います。
  ///
  /// [onReorder]を定義することで順番が変更されたときのコールバックを指定することができ、実データの変更を行うことが可能です。
  ///
  /// [top]を設定すると[source]の要素を並べる前に[top]の要素を並べます。
  ///
  /// [bottom]を設定すると[source]の要素を並べた後に[bottom]の要素を並べます。
  ///
  /// [insert]を設定すると[source]の[insertPosition]の位置に[insert]が挿入されます。
  ///
  /// [listenWhenListenable]が`true`になっている場合、[source]に[Listenable]を継承している場合[ListenableListener]が各要素にラップされます。
  /// そのため、[source]の各要素をそれぞれ監視し、いずれかの要素が更新された場合その要素のみ描画が更新されます。
  const ReorderableListBuilder({
    super.key,
    this.scrollDirection = Axis.vertical,
    this.reverse = false,
    this.controller,
    this.primary,
    this.physics,
    this.shrinkWrap = false,
    this.padding,
    this.top,
    this.insert,
    this.insertPosition = 0,
    this.bottom,
    this.itemExtent,
    required this.source,
    required this.builder,
    required this.onReorder,
    this.cacheExtent,
    this.keyBuilder,
    this.listenWhenListenable = true,
    this.dragStartBehavior = DragStartBehavior.start,
    this.keyboardDismissBehavior = ScrollViewKeyboardDismissBehavior.manual,
    this.restorationId,
    this.clipBehavior = Clip.hardEdge,
  })  : _topLength = top.length,
        _length = top.length + source.length + bottom.length + insert.length,
        _topSourcelength = top.length + source.length + insert.length;

  ///Method to define [ReorderableListBuilder.onReorder] when the data in the list consists of [M].
  ///
  /// The elements to be reordered are passed to [data], [oldPosition] and [newPosition] are the old and new positions, and [reordered] is the list after the reordering.
  ///
  /// Specify a callback to [onRetrieve] to retrieve the numerical value of the order.
  ///
  /// Specify a callback to execute after reordering in [onUpdate].
  ///
  /// Specify the initial value to be passed to [defaultOrderValue] if [key] has no value.
  ///
  /// リストのデータが[M]で構成されている場合の[ReorderableListBuilder.onReorder]を定義するためのメソッド。
  ///
  /// [data]に順番が入れ替わった対象の要素、[oldPosition]、[newPosition]に新旧の位置、[reordered]に順番が入れ替わった後のリストが渡されます。
  ///
  /// [onRetrieve]に順番の数値を取得するためのコールバックを指定します。
  ///
  /// [onUpdate]に順番を入れ替えた後に実行するコールバックを指定します。
  ///
  /// [defaultOrderValue]に[key]に値がなかったときに渡す初期値を指定します。
  static Future<M> defaultOnReorder<M>(
    int oldPosition,
    int newPosition,
    M data,
    List<M> reordered, {
    required double Function(M data) onRetrieve,
    required FutureOr<void> Function(M data, double order) onUpdate,
    double? defaultOrderValue,
  }) async {
    if (reordered.length <= 1) {
      return data;
    }
    if (oldPosition < newPosition) {
      if (reordered.length <= newPosition) {
        await onUpdate(
          data,
          defaultOrderValue ?? DateTime.now().millisecondsSinceEpoch.toDouble(),
        );
      } else {
        await onUpdate(
          data,
          (onRetrieve(reordered[newPosition]) +
                  onRetrieve(reordered[newPosition - 2])) /
              2.0,
        );
      }
    } else {
      if (newPosition <= 0) {
        await onUpdate(
          data,
          onRetrieve(reordered[1]) / 2.0,
        );
      } else if (reordered.length - 1 <= newPosition) {
        await onUpdate(
          data,
          defaultOrderValue ?? DateTime.now().millisecondsSinceEpoch.toDouble(),
        );
      } else {
        await onUpdate(
          data,
          (onRetrieve(reordered[newPosition + 1]) +
                  onRetrieve(reordered[newPosition - 1])) /
              2.0,
        );
      }
    }
    return data;
  }

  /// Method to define [ReorderableListBuilder.onReorder] when the list data consists of [DynamicMap].
  ///
  /// The elements to be reordered are passed to [map], [oldPosition] and [newPosition] are the old and new positions, and [reordered] is the list after the reordering.
  ///
  /// Specify the callback to be executed after reordering in [onSaved]. Specify the key of the element for which the order value is to be entered in [key]. Specify the initial value to be passed to [defaultOrderValue] if [key] has no value.
  ///
  /// リストのデータが[DynamicMap]で構成されている場合の[ReorderableListBuilder.onReorder]を定義するためのメソッド。
  ///
  /// [map]に順番が入れ替わった対象の要素、[oldPosition]、[newPosition]に新旧の位置、[reordered]に順番が入れ替わった後のリストが渡されます。
  ///
  /// [onSaved]に順番を入れ替えた後に実行するコールバックを指定します。[key]には順番の値を記載する要素のキーを指定します。[defaultOrderValue]に[key]に値がなかったときに渡す初期値を指定します。
  static Future<M> defaultOnReorderForDynamicMap<M extends DynamicMap>(
    int oldPosition,
    int newPosition,
    M map,
    List<M> reordered, {
    FutureOr<void> Function(M data)? onSaved,
    String key = "order",
    double? defaultOrderValue,
  }) =>
      defaultOnReorder(
        oldPosition,
        newPosition,
        map,
        reordered,
        onRetrieve: (map) => map.get(key, 0.0),
        onUpdate: (map, order) async {
          map[key] = order;
          await onSaved?.call(map);
        },
        defaultOrderValue: defaultOrderValue,
      );

  /// Scroll direction.
  ///
  /// スクロールの方向。
  final Axis scrollDirection;

  /// If this is `true`, the scroll direction is reversed.
  ///
  /// これが`true`の場合、スクロールの方向が逆になります。
  final bool reverse;

  /// If you want to control scrolling from the outside, pass [ScrollController].
  ///
  /// スクロールを外部からコントロールしたい場合、[ScrollController]を渡します。
  final ScrollController? controller;

  /// If this is `true`, it is recognized as the primary scrolling view.
  ///
  /// これが`true`の場合、プライマリーのスクロールビューとして認識されます。
  final bool? primary;

  /// Pass [ScrollPhysics] to set the scrolling method.
  ///
  /// スクロールの方法を設定するために[ScrollPhysics]を渡します。
  final ScrollPhysics? physics;

  /// If this is `true`, the area for scrolling is reduced to only where the content resides.
  ///
  /// これが`true`の場合、スクロール用のエリアをコンテンツが存在するところのみに縮小します。
  final bool shrinkWrap;

  /// List view padding.
  ///
  /// リストビューのパディング。
  final EdgeInsetsGeometry? padding;

  /// The height (width) of each element. If [Null], the bare height (width) of each element is set.
  ///
  /// 各要素の高さ（幅）。[Null]の場合は要素ごとの素の高さ（幅）が設定されます。
  final double? itemExtent;

  /// If an element of [insert] exists, insert [insert] at the [insertPosition]th position of [source].
  ///
  /// [insert]の要素が存在する場合、[source]の[insertPosition]番目に[insert]を挿入します。
  final int insertPosition;

  /// If [listenWhenListenable] is `true`, [ListenableListener] will be wrapped around each element if [source] inherits [Listenable].
  /// Therefore, each element of [source] is monitored individually, and if any element is updated, only that element is updated in the drawing.
  ///
  /// [listenWhenListenable]が`true`になっている場合、[source]に[Listenable]を継承している場合[ListenableListener]が各要素にラップされます。
  /// そのため、[source]の各要素をそれぞれ監視し、いずれかの要素が更新された場合その要素のみ描画が更新されます。
  final bool listenWhenListenable;

  /// When [insert] is set, [insert] is inserted at the position of [insertPosition] in [source].
  ///
  /// [insert]を設定すると[source]の[insertPosition]の位置に[insert]が挿入されます。
  final List<Widget>? insert;

  /// If [top] is set, the [top] elements are lined up before the [source] elements are lined up.
  ///
  /// [top]を設定すると[source]の要素を並べる前に[top]の要素を並べます。
  final List<Widget>? top;

  /// If [bottom] is set, the elements of [bottom] are lined up after the elements of [source] are lined up.
  ///
  /// [bottom]を設定すると[source]の要素を並べた後に[bottom]の要素を並べます。
  final List<Widget>? bottom;

  /// List of data to be displayed in the list.
  ///
  /// リストに表示するデータの一覧。
  final List<T> source;

  /// When reordering, a key identifying the element is required.
  ///
  /// This callback can be specified to specify its key element.
  ///
  /// If not specified, [item] is used as is.
  ///
  /// リオーダーを行う場合、要素を識別するキーが必要になります。
  ///
  /// このコールバックを指定するとそのキーとなる要素を指定することができます。
  ///
  /// 指定されない場合は、[item]がそのまま利用されます。
  final Object Function(T item)? keyBuilder;

  /// Builder to display on the list.
  ///
  /// [context] is passed as [BuildContext], [item] as each element, and [index] as the array number of the element.
  ///
  /// リストに表示するためのビルダー。
  ///
  /// [context]に[BuildContext]、[item]に各要素、[index]が要素の配列番号が渡されます。
  final List<Widget>? Function(BuildContext context, T item, int index) builder;

  /// Specify the area to hold the cache.
  ///
  /// キャッシュを保持する領域を指定します。
  final double? cacheExtent;

  /// Provides the ability to initiate a drag.
  ///
  /// ドラッグを開始するための機能を提供します。
  final DragStartBehavior dragStartBehavior;

  /// Define here if you want to implement a mechanism to close the keyboard triggered by scrolling.
  ///
  /// スクロールをトリガーにキーボードを閉じる仕組みを実装する場合ここを定義します。
  ///
  /// ```dart
  /// keyboardDismissBehavior: ScrollViewKeyboardDismissBehavior.onDrag,
  /// ```
  final ScrollViewKeyboardDismissBehavior keyboardDismissBehavior;

  /// Restore ID to save and restore the scroll offset of the listing.
  ///
  /// If a restore ID is specified, the listing retains the current scroll offset and restores it during state restoration.
  ///
  /// リストのスクロールオフセットを保存および復元するための復元ID。
  ///
  /// 復元IDを指定すると、リストは現在のスクロールオフセットを保持し、状態の復元中にそれを復元します。
  final String? restorationId;

  /// Specify here to adjust the clip function of the listing.
  ///
  /// リストのクリップ機能を調整する場合ここを指定します。
  final Clip clipBehavior;

  /// Callback when the order is changed. This callback can be used to change the actual data.
  ///
  /// The elements to be reordered are passed to [item], the old and new positions to [oldPosition] and [newPosition], and the list after the reordering to [reordered].
  ///
  /// 順番が変更されたときのコールバック。このコールバックで実データの変更を行うことが可能です。
  ///
  /// [item]に順番が入れ替わった対象の要素、[oldPosition]、[newPosition]に新旧の位置、[reordered]に順番が入れ替わった後のリストが渡されます。
  final void Function(
    int oldPosition,
    int newPosition,
    T item,
    List<T> reordered,
  ) onReorder;

  final int _topLength;
  final int _length;
  final int _topSourcelength;

  @override
  State<StatefulWidget> createState() => _ReorderableListBuilderState<T>();
}

class _ReorderableListBuilderState<T> extends State<ReorderableListBuilder<T>> {
  late List<T> _source;

  @override
  void initState() {
    super.initState();
    _source = List.from(widget.source);
  }

  @override
  void didUpdateWidget(ReorderableListBuilder<T> oldWidget) {
    super.didUpdateWidget(oldWidget);
    if (widget.source != oldWidget.source ||
        widget.source.length != oldWidget.source.length ||
        widget.source.length != _source.length) {
      _source = List.from(widget.source);
      setState(() {});
    }
  }

  @override
  Widget build(BuildContext context) {
    return ReorderableListView.builder(
      scrollDirection: widget.scrollDirection,
      reverse: widget.reverse,
      onReorder: _reorder,
      primary: widget.primary,
      physics: widget.physics,
      shrinkWrap: widget.shrinkWrap,
      padding: widget.padding?.resolve(TextDirection.ltr),
      itemExtent: widget.itemExtent,
      itemBuilder: _builder,
      itemCount: widget._length,
      cacheExtent: widget.cacheExtent,
      dragStartBehavior: widget.dragStartBehavior,
      keyboardDismissBehavior: widget.keyboardDismissBehavior,
      restorationId: widget.restorationId,
      clipBehavior: widget.clipBehavior,
    );
  }

  void _exchange(int oldPosition, int newPosition) {
    if (oldPosition >= newPosition) {
      _source.insert(newPosition, _source.removeAt(oldPosition));
    } else {
      _source.insert(newPosition - 1, _source.removeAt(oldPosition));
    }
  }

  void _reorder(int oldPosition, int newPosition) {
    if (oldPosition < widget._topLength || newPosition < widget._topLength) {
      return;
    } else if (oldPosition < widget._topSourcelength &&
        newPosition <= widget._topSourcelength) {
      if (_source.isEmpty) {
        return;
      } else if (_source.length <= widget.insertPosition) {
        final pos = oldPosition - widget._topLength;
        if (pos < _source.length) {
          final item = _source[pos];
          final npos = newPosition - widget._topLength;
          if (npos < _source.length) {
            setState(() {
              _exchange(pos, npos);
              widget.onReorder.call(pos, npos, item, _source);
            });
          }
        }
      } else {
        final pos = oldPosition - widget._topLength;
        if (pos >= widget.insertPosition &&
            pos < widget.insertPosition + widget.insert.length) {
          return;
        } else if (pos < widget.insertPosition) {
          final item = _source[pos];
          final npos = newPosition - widget._topLength;
          if (npos >= widget.insertPosition &&
              npos < widget.insertPosition + widget.insert.length) {
            return;
          } else if (npos < widget.insertPosition) {
            setState(() {
              _exchange(pos, npos);
              widget.onReorder.call(pos, npos, item, _source);
            });
          } else {
            setState(() {
              _exchange(pos, npos - widget.insert.length);
              widget.onReorder
                  .call(pos, npos - widget.insert.length, item, _source);
            });
          }
        } else {
          final item = _source[pos - widget.insert.length];
          final npos = newPosition - widget._topLength;
          if (npos >= widget.insertPosition &&
              npos < widget.insertPosition + widget.insert.length) {
            return;
          } else if (npos < widget.insertPosition) {
            setState(() {
              _exchange(pos - widget.insert.length, npos);
              widget.onReorder
                  .call(pos - widget.insert.length, npos, item, _source);
            });
          } else {
            setState(() {
              _exchange(
                pos - widget.insert.length,
                npos - widget.insert.length,
              );
              widget.onReorder.call(
                pos - widget.insert.length,
                npos - widget.insert.length,
                item,
                _source,
              );
            });
          }
        }
      }
    }
  }

  Widget _builder(BuildContext context, int i) {
    if (i < widget._topLength) {
      return widget.top![i];
    } else if (i < widget._topSourcelength) {
      if (_source.isEmpty) {
        return widget.insert![i - widget._topLength];
      } else if (_source.length <= widget.insertPosition) {
        final pos = i - widget._topLength;
        if (pos < _source.length) {
          return _listenableBuilder(context, pos);
        } else {
          return widget.insert![i - _source.length - widget._topLength];
        }
      } else {
        final pos = i - widget._topLength;
        if (pos >= widget.insertPosition &&
            pos < widget.insertPosition + widget.insert.length) {
          return widget.insert![pos - widget.insertPosition];
        } else if (pos < widget.insertPosition) {
          return _listenableBuilder(context, pos);
        } else {
          return _listenableBuilder(context, pos - widget.insert.length);
        }
      }
    } else {
      return widget.bottom![i - widget._topSourcelength];
    }
  }

  Widget _sourceBuilder(BuildContext context, T item, int pos, Key? key) {
    final children = widget.builder.call(context, item, pos);
    if (children.isEmpty) {
      return const SizedBox.shrink();
    } else if (children.length <= 1) {
      return children!.firstOrNull ?? const SizedBox.shrink();
    } else {
      return Column(
        mainAxisAlignment: MainAxisAlignment.start,
        crossAxisAlignment: CrossAxisAlignment.center,
        children: children!,
      );
    }
  }

  Widget _listenableBuilder(
    BuildContext context,
    int pos,
  ) {
    final item = _source[pos];
    final keyObject = widget.keyBuilder?.call(item) ?? item;
    final key = ValueKey(keyObject);
    if (!widget.listenWhenListenable || item is! Listenable) {
      return Container(
        key: key,
        child: _sourceBuilder(context, item, pos, key),
      );
    }
    return ListenableListener<Listenable>(
      key: key,
      listenable: item,
      builder: (context, listenable) {
        return _sourceBuilder(context, item, pos, key);
      },
    );
  }
}
